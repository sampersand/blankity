module Blankity::To
  # Helper method to create new `BlankSlate`s. Args:
  # - `to_method`: The method to use, eg `to_i`
  # - `value`: What to return when `to_method` is called
  # - `methods`: Optional list of methods from to define, using `value`'s definition
  # - `hash`: Helper to also add `hash` and `eql?` to `methods`, so it can be used as a hash key
  # - `kernel_methods`: Optional list of methods from `Kernel` to also define
  # - `block`: If provided, a block to also run
  def self?.to_helper: (untyped to_method, untyped value, ?methods: untyped, ?kernel_methods: untyped, ?hash: bool) { (?) -> untyped } -> untyped

  # Create a type which _only_ responds to `.to_i`. See `to_helper` for details.
  def self?.i: (Integer value, **untyped) ?{ (?) -> void } -> _ToI

  # Create a type which _only_ responds to `.to_int`. See `to_helper` for details.
  def self?.int: (Integer value, **untyped) ?{ (?) -> void } -> _ToInt

  # Create a type which _only_ responds to `.to_s`. See `to_helper` for details.
  def self?.s: (String value, **untyped) ?{ (?) -> void } -> _ToS

  # Create a type which _only_ responds to `.to_str`. See `to_helper` for details.
  def self?.str: (String value, **untyped) ?{ (?) -> void } -> _ToStr

  # Create a type which _only_ responds to `.to_a`. See `to_helper` for details.
  #
  # This supports `a(1, 2, 3)` as a convenient shorthand for `a([1, 2, 3])`. To
  # create a `.to_a` that returns an array containing just an array, use `a([array])`.
  def self?.a: [T] (array[T] ary, **untyped kw) { (?) -> void } -> _ToA[T]
             | [T] (*T ary, **untyped kw) { (?) -> void } -> _ToA[T]

  # Create a type which _only_ responds to `.to_ary`. See `to_helper` for details.
  #
  # This supports `ary(1, 2, 3)` as a convenient shorthand for `ary([1, 2, 3])`. To
  # create a `.to_ary` that returns an array containing just an array, use `ary([array])`.
  def self?.ary: [T] (array[T] ary, **untyped kw) { (?) -> void } -> _ToAry[T]
               | [T] (*T ary, **untyped kw) { (?) -> void } -> _ToAry[T]

  # Create a type which _only_ responds to `.to_h`. See `to_helper` for details.
  #
  # This supports passing in key/values directly via `h('a' => 'b')` as a convenient
  # shorthand for `h({'a' => 'b'})`, but the shorthand version doesn't allow you
  # to supply keyowrd arguments that `to_helper` expects. Use `h({'a' => 'b'}, ...)` for that.
  def self?.h: [K, V](Hash[K, V] hash) { (?) -> void } -> _ToH[K, V]
             | (?untyped? hash, **untyped kw) { (?) -> void } -> untyped

  # Create a type which _only_ responds to `.to_hash`. See `to_helper` for details.
  #
  # This supports passing in key/values directly via `h('a' => 'b')` as a convenient
  # shorthand for `h({'a' => 'b'})`, but the shorthand version doesn't allow you
  # to supply keyowrd arguments that `to_helper` expects. Use `h({'a' => 'b'}, ...)` for that.
  def self?.hash: (?untyped? hash, **untyped kw) { (?) -> void } -> untyped

  # Create a type which _only_ responds to `.to_sym`. See `to_helper` for details.
  def self?.sym: (Symbol value, **untyped) ?{ (?) -> void } -> _ToSym

  # Create a type which _only_ responds to `.to_r`. See `to_helper` for details.
  def self?.r: (Rational value, **untyped) ?{ (?) -> void } -> _ToR

  # Create a type which _only_ responds to `.to_c`. See `to_helper` for details.
  def self?.c: (Complex value, **untyped) ?{ (?) -> void } -> _ToC

  # Create a type which _only_ responds to `.to_f`. See `to_helper` for details.
  def self?.f: (Float value, **untyped) ?{ (?) -> void } -> _ToF

  # Create a type which _only_ responds to `.to_regexp`. See `to_helper` for details.
  def self?.regexp: (Regexp value, **untyped) ?{ (?) -> void } -> Regexp::_ToRegexp

  # Create a type which _only_ responds to `.to_path`. See `to_helper` for details.
  def self?.path: (String value, **untyped) ?{ (?) -> void } -> _ToPath

  # Create a type which _only_ responds to `.to_io`. See `to_helper` for details.
  def self?.io: (IO value, **untyped) ?{ (?) -> void } -> _ToIO

  # Create a type which _only_ responds to `.begin`, `.end`, and `.exclude_end?`
  # (the methods required to be considered a "custom range," eg for `Array#[]`.) See
  # `to_helper` for details.
  def self?.range: [T] (T? begin_, T? end_, ?bool exclude_end, ?methods: untyped, ?kernel_methods: untyped, ?hash: bool) { (?) -> void } -> _Range[T]
end
